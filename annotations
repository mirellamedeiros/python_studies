Welcome to my python annotations! This is mostly unnorganized, as I write it while studying and following classes and examples, so usually to find a specific information I search for key words!
Eventually I plan to rewrite everything here in a better way!
If you're a python student like me, or just a programmer in general, good luck and good studies (:

Variables

Assignment of variables:
	ex_var = 5

Reassignment of variables:
	ex_var = 7

Variable naming rules:
	- Don't start with numbers or spaces
	- No special characters
	- "variableExample" is ok (camelCase)
	- "variable_case_example" is also ok (snake_case)
	- "v4riabl3" is also ok

Basic data types

Floating-point numbers - it's a number which has a decimal point
	float_1 = 1.234

Integers - numbers with no fractional parts
	int_1 = 7

Booleans - either true or false
	bool_1 = True
	bool_2 = False

Comments
Use the "#" symbol (with a space after)

Expressions and basic math operators
In python, we use +, -, / and *

Exponentiation: 
4 ** 4  (4*4, four times)
= 256

Floor division:
16 // 5 (returns the smallest integer number)
= 3

Modulus:
7 % 3
= 1

Assignment operators: operators used for reassignments

Addition assignment: += 
	add_assign = 5

Why use them?
	add_assign = add_assign + 7 (longer, more code)
	add-assign += 7 (less code!)

Subtraction:
	sub = 10
	sub -= 5
	= 5

Multiplication:
	mult = 10
	mult *= 5
	=50

Division:
	div = 10
	div /= 5
	=2.0

Exponentiation:
	exp = 10
	exp **= 2
	= 100

Floor division: (arredonda pro menor inteiro mais próximo, o oposto, arredondando pra cima é o ceil - ceiling)
	floor = 10
	floor //= 6
	=1

Modulo: (resto da divisão)
	mod = 10
	mod %= 7
	=3

Order of operations: (from highest to lowest priority)

() 
**
%, /, //, and *
+ and -

More on floats
When using decimal numbers in python expressions, there can be approximation erros. Since python is built on top on C, and C uses a limited number of digits to represent a float
To avoid using floats in expressions, you can make them integers by multiplying the values by 10 or 100 and then divide them by the same value at the end:
	ex1 = 1.23 + 2.80
	(*100)
	ex2 = (123 + 280) / 100
	print(ex2)
	= 4.03
	
You can also use the round() function if you know the number of digits that are supposed to be after the decimal point in the result, or you want an approximation and only a certain number or digits to be displayed after the decimal point:
	ex3 = 1.23 + 2.80
	print(round(ex3, 2))   
	=4.03
The 2 means that you only want 2 decimal numbers after the decimal point, it's an approximation!

Strings
A string is a sequence of characters in between single or double quotes, it`s preferabe to use double quotes because then you can use the single quotes within that string without having to use scape sequences (we'll see that later).

  string1 = 'this is a string!'
  string2 = "this is also a string!"
  string3 = '1234'
  string4 = "!#@@#$@"
  string5 = ''
  string6 = "HeLlO wOrLd"

Every string is assigned an index number, which is the number of characters in that string, in python and other languages, the index starts at zero. Index numbers allow you to acess characters or groups of characters using them:

  string_index = "mimi likes orange juice"  # starting from zero, the index number 3 corresponds to the last character !
  print(string_index[2]) # will print the first "m" !
  print("orange juice"[7]) # will print "j" !

String Slicing
Allows you to get slices of a string and assign them to variables or print them:

  print(string_index[:3]) 
  print(string_index[4:6])
  print(string_index[7:])
  mimi_slice = string_index[:4] # assign a slice to a variable !
  print(mimi_slice)

String Concatenation
Adds the strings together with the "+":

  print("mimi" + " " + "is cute !")
  mimi_concatenation = "hello " + "mimi !"
  print(mimi_concatenation[3:7])

type() 
The type function allows you to find out the data type of a piece of data:

  mimi_boolean = True
  print(type(mimi_boolean) # will result in a <class 'bool'>

str()
The string function converts whatever is put between the parentheses into a string.

Escape Sequences
Are special characters you can use and strings which enable you to, for example, insert quotes within them, and make different parts of strings appear on different lines in the output:

\t
The TAB character is used to make a horizontal space or indent when working with strings!

  print("I\treally\tlike\tpython\t!") # I  really  like  python  !

\n
Stands for NEW LINE, as in:

  print("hello!\nthis is a letter\nkind regards,\nmimi."

\' and \"
Use this to put quotes In your strings, depending or if you have used '' or "" to create the strings.

\\
The backlash escape sequence is used whenever you want to put a backlash in a string.

These are only the most common escape sequences, there are tons more online!

input()
Makes your programs get and use input from a user:

  name = input("enter your name here: ")

int() and float()
Similarly to the str() function, with these you can turn strings into numbers. This is very useful when you want to get numbers from a user using the input function, for example.

Functions
Allow you to reuse code on different variables and values. There are at least 5 parts to every function, the key word def, a function name, parentheses, a colon, then code that the function is meant to run:

  def mimi_function():
    print("mimi is learning python!" # here we defined what the function must do


  mimi_function() # and here we are calling the function!

After you define a function, you should have two blank lines after it before creating more code!

Function Parameters
A sixth element can be added to a function in the form of a parameter or multiple parameters. A parameter is a placeholder name for the variable or data that you want your function to run its code on.

  def mimi_function2(mimi_parameter):
    print("mimi says: " + mimi_parameter)


  mimi_function("hello world") # calling the function with a parameter !

Multiple Parameters
When you define a function, you can create as many parameters as you want, they should be separated by ", ". And if you have anything before the function definition, you should also put two lines of distance!

When a function is called, the items that you pass to it are called arguments.

Default Parameters
You can give a functions parameters values to default to in the event that the function is called without arguments for those parameters:

  def mimi_function3(mimi_p1=2, mimi_p2=5):
    print(mimi_p1 * mimi_p2)


  mimi_function3(6) # and here the result will be 30, because we are swapping only the 2 !

Return
You'll often want your function to produce something that can be used in expressions or assigned to a variable rather than just printed.

  def mimi_function4(mimi_p1=2, mimi_p2=5):
    return mimi_p1 * mimi_p2


  mimi_var = mimi_function4()
  print(mimi_var)

((look up prism_exercise on this repository to see a good example of using return with expressions and input !))

Introduction to Modules
Modules contain sets of functions that can be used for many different things, to use these functions you must import their modules:

-> Generic import - using just the keyword "import" and then the name of the module; "random" is a module that contains functions for creating random things such as random float's of interger values
	
	import random
	
To use a function from a module that has been generically imported you must call it, like here with the randint function:

	import random

	print(random.randint(1, 10))

Here we got a random value between (greater/smaller than or equal to) 1 and 10!
	
-> Function import - when a specific function is imported from a module:
	
	from random import randit

	print(randint(2, 9))

-> Universal import - when you import any function from a module, so when you call a function from that module you do not need to type the module's name and a .
	
	from random import *

	print(random()) # returns a float that is greater than or equal to 0.0 and less than 1.0 when it's called!
	
Variable Scope

In python, you can have a variable within a function that has the same name of a variable outside that function, however, despite having the same name, those variables are not the same! 
Variables created within functions have a local scope, as opposed to those created outside functions, which have a global scope.

	mimi_var = "global scope!"


	def mimi_function():
		mimi_variable = "local scope!"
		return mimi_variable

	print(mimi_variable)
	print(mimi_function())

-> Local variables cannot be used by code in the global scope
-> Global variables can be acessed by code in the local scope
-> The local scope of one function can't use variables from another function's local scope
-> You can use the same name for different variables as long as they are in different scopes

Intro to Flow Control

Flow charts are a type of diagram with a starting point which can have multiple end points.

To represent a "yes or no" types of flow, we can use boolean values, comparison operators and boolean operators.
	
-> Boolean values: True or False
	
-> Comparison operators: >, <, >=, <=, != and ==

-> Comparisons made using these operators evaluate to a boolean value

-> == and != can also be used to compare strings, this comparison IS case sensitive

-> In these comparisons, floats and intergers can be equivalent

= vs ==
A single equal symbol is assignment to variables, while two is a comparison


Boolean operators: AND, OR and NOT
	
The AND boolean operator will only return "true" if both statements it compares are true (T+T, instead of F+T, T+F or F+F)

The OR boolean operator will only return "false" if both statements it compares are false (F+F, instead of F+T, T+F or T+T)

The NOT boolean operator makes whatever is put after it evaluate to its opposite, as in "not True" evaluates to False, and "not False" evaluates to True


Flow Control Statements: If Statements

	mimi = input("mimi is: ")

	if mimi == "cute":
		print("yes, very :)")

Else Statements

	mimi = input("mimi is: ")

	if mimi == "cute":
		print("yes, very :)")
	else:
		print("try again!")

Nested If and Else Statements

	mimi_average = float(input("mimi, what's your grade average "))
	mimi_assignments = input("and did you turn in all of your assignments? "))

	if mimi_average >= 7.0:
		if mimi_assignments == "yes":
			print("you will graduate just fine!")
		else:
			print("mimi, you've forgotten your assignments!!!")
	else:
		print("this is a complete disaster!")


Elif Statements - also known as else/if statements
It allows us to provide as many additional conditions to check as we need without the messines that comes with having to use multiple nested if and if/else statements blocks

	mimi_number = int(input("mimi, enter a integer number between 1 and 100: "))

	if mimi_number < 0:
		print("that's less than zero!")
	elif mimi_number == 0:
		print("that's zero!")
	elif 0 < mimi_number <= 100:
		print("well done!")
	else:
		print("that's greater than 100!")


Truthy and Falsey Values: 

For strings

	mimi = input("type something here: ")

	if mimi:
		print("thanks!")
	else:
		print(":(")

Sometimes you might find code like this, where instead of haing a condition using comparison operators, the if statement just has a string in front of it. However, this code will work because of truthy and falsey values for strings.
For strings, anything other than an empty string is truthy. An empty string is falsey, meaning that it's equivalent to the "false" value.
	
Even so, it's better to be more specific with your conditions, for readability:

	mimi = input("type something here: ")

	if mimi != "":
		print("thanks!")
	else:
		print(":(")	

For integers
Zero is the falsey value, and any other integers are truthys
	
For floats
Zero point zero (0.0) is the falsey value, and any other floats are truthy
	
bool()
This function can tell you the equivalent boolean value of anything

  	print(bool(0)) # False
	print (bool(400)) # True
	print(bool(1.23) # True

While Loops
Loops are an useful tool for when you want to have code run on every item in a piece of data that has indexes such as string.

	mimicounter = 0

	while mimicounter < 3:
		print("it's less than three")
		mimicounter += 1

When the condition given on the while loop evaluates to false it will stop. This is important because we should avoid infinite loops by making sure each while loop created has a condition which stops it from running its code an infinite amount of times. A closed loop if a while loop that will eventually stop running when its condition evaluates to false, which is good! 

For loops

When using the while loops, you won't know how many times the loop will run before it ends. 
The for loop is particularly useful because it is a type of loop that is controlled by the lenght of the iterable piece of data that it's being used on rather than the condition.

	word = "mimi"

	for letter in word:
		print(letter)

range()
Is a function that returns a sequence of numbers and is usually used for iterating over with a for loop.
It can take three arguments: start, stop and step; and it can be used with one, two or all three of them.

	mimi = range(5)

	for num in mimi:
		print(num)

Calling range() with only one argument makes it so that the sequence of numbers returned by range will start at zero, then move up in increments of one untill one less than the argument is reached.

Also note that when range() is called, the sequence of numbers that it returns has its own data type, called range:

	mimi = range(5)

	print(type(mimi)) # <class 'range'>

Calling range() with two arguments creates and returns a sequence of numbers which starts at the first argument and increments up by one untill it stops at one less than the second argument. 

	mimi = range(5, 10)

	for num in mimi:
		print(num)

When range() is called with three arguments, it creates a sequence of numbers that starts at the first argument, increments up or down by the third argument and ends at one less than the second argument. The third argument, also known as step size, can be used to increment down since it can be negative.

	mimi = range(1, 8, 2)

	for num in mimi:
		print(num)


String methods 1:

.upper() and .lower()
The upper string method allows you to make everything in a string uppercase.

.isupper() and .islower()
Return a boolean value

.isalpha() 
Returns true is the string it's being used on only contains letters

.isalnum()
Only numbers and letters

.isadecimal()
Only numbers

.isspace() 
Only spaces

.istitle() and .title()
Only titlecase (words in the string all have the first letter capitalized), the method makes a string titlecase

.startswith() and .endswith()
Both take a string as its argument, return true if the string starts or ends with that argument
Both are also case-sensitive

.join()
Useful when you have multiple strings that you want to join together in a single string

	print("".join(["one", "two", "three"])) # onetwothree
	print(" ".join(["one", "two", "three"])) # one two three
	print(", ".join(["one", "two", "three"])) # one, two, three

.split()
Does the opposite of the .join() method, it splits the string and returns a list

	print("eggs, milk, waffles, bacon".split()) # ['eggs,', 'milk,', 'waffles,', 'bacon']

Notice how the commas were kept, this is because by default .split() separates the words in a string by spaces, if you wanted to separate them by commas:

	print("eggs, milk, waffles, bacon".split(", ")) # ['eggs', 'milk', 'waffles', 'bacon']

String methods 2

.rjust() and .ljust()
These methods can take one argument and return right justified or left justified versions of the strings they are called on
The integer entered in the argument of these methods will be the total lenght of the string that is returned

.center()
Adds characters on both sides of the string

.strip(), .rstrip() and .lstrip()
Remove spaces or characters from a string, their arguments also need to be strings

.replace()
Used to search for and replace a string, it takes two strings as arguments, the first being the search one and the second being the replacement

	print("good morning!".replace("morning", "afternoon"))

.len()
The length function lets you get the lenght of a iterable type such as a string

.format() 
Normally you would concatenate strings using the "+" operator.
This method allows us to put {} inside strings to  mark where we want other strings to be inserted:

	var_1 = input("name? ")
	var_2 = input("age? ")
	var_3 = input("occupation? ")

	print("{} is {} years old, and works as a {}.".format(var_1, var_2, var_3))

Introduction to lists
Values within a list are known as "items".

To create a list, use  [] and "," between the items:

	list_1 = [1, 2, 3, 4]
	list_2 = [2.45, 67.465]
	list_3 = ["churrasco", "pão", "vinagrete"]
	list_4 = [True, False]
	list_5 = [[1, 2, 3], ["café da manhã", "almoço", "jantar"]]
	list_6 = [1, "bolo de milho", True]

A list can contain values of any data type, even other lists (a list of lists); the items also do not need to be all of the same data type.

The list() function takes an iterable data type, such as a string, as an argument and converts it to a list that it then returns.

	print(list("mimi")) # ['m', 'i', 'm', 'i']

The "in" and "not in" operators  can be used whether a value is or isn't in a list:

	mimi_list = [1, 2, 3, 4]

	print(1 in mimi_list) # True

You can also assign the value of that to a variable:

	mimi_list = [1, 2, 3, 4]

	mimi_check = 1 not in mimi_list
	print(mimi_check) # False

Indexes and slicing
Each of the characters on a string, or item on a list, has its own index number; it always starts at 0.

	mimi_list = ["indexnum0", "indexnum1", "indexnum2"]
	print(mimi_list[1]) # indexnum1

We can access an item from a list by using its index number.

You can also access items from a list within another list:

	mimi_list = ["indexnum0", "indexnum1", "indexnum2"]
	print(mimi_list[2][1]) # 3

You can access a value from a piece of data that has index numbers and is also an item within a list:

	mimi_list = ["indexnum0", "indexnum1", "indexnum2"]
	print(mimi_list[1][8]) # 1

Negative indexes
While index numbers and lists start from zero and go up by one for each item, a negative integer can be used when accessing by index in python.

Start from the end of a list and go backwards:

	mimi_list = [1, 2, 3, 4, 5]
	print(mimi_list[-1]) # 5

Items that have been accessed by index from lists can also be used in expressions and string concatenations provided they are the correct data type.

	mimi_list = [True, 1, 2.34, "world!"]
	print(mimi_list[2] + 5.67)
	print("hello " + mimi_list[-1])

List slicing

When you slice a list you get a list made up of a segment from a larger list:

	mimi_list = [1, 2, 3, 4, 5, 6, 7, 
	
	print(mimi_list[:4]) # starts at the beginning, ends at index 4
	print(mimi_list[3:8]) # starts at index 3, ends at index 8
	print(mimi_list[6:]) # starts at index 6, goes to the end of string

You can reassign the items in a list, just like a variable's value:

	mimi_list = [1, 2, 3]
	print(mimi_list)
	mimi_list[1] = 4
	print(mimi_list)

del statements and list methods

Delete values from a list:

	mimi_list = [1, 2, 3]
	del mimi_list[1]
	print(mimi_list)

Remove what you passed as an argument from a string list:

	mimi_list = ["one", "two", "three"]
	mimi_list.remove("two")
	print(mimi_list)

del vs .remove()
Del removes an item based on its index number, while the remove method searches a list from whatever item you passed it as an argument and removes it from the list.

.append()
Takes an argument and adds it to the end of the list its used on:

	mimi_list = ["mimi", "is"]
	mimi_list.append("cute")
	print(mimi_list)

.insert()
Similar to .append() but you can add it anywhere on the list:

	mimi_list = ["mimi", "is", "cute"]
	mimi_list.insert(2, "very")
	print(mimi_list)

.sort()
Can be used to sort lists made up of items that are all numbers, or items that are all strings.

-> If you type reverse=True in the parentheses of the .sort() method when calling it, you can get items from a list in reverse order.

-> The .sort() method cannot be used on mixed lists with different data types. It can't identify if strings are greater than numbers, or put numbers in an alphabetical order.

-> Another thing to take note of when using the .sort() method is that the boolean value False will be taken as 0, and the value True will  be taken as 1.

-> One final important thing to note about the sort method is that it doesn`t actually use alphabetical order, it uses ASCIIbetical order. 
The only difference is that in ASCIIbetical order, uppercase letters come before lowercase letters.

-> If you need to sort the list of strings by alphabetical order, use .sort(key=str.lower)

.index()
This method allows you to find out the index number of the item you pass it. When called, the .index() method returns the index number as an integer.

	medieval_breakfast = ["ale", "bread", "cheese"]
	print(medieval_breakfast.index("bread"))

If an item appears more than once on a list, the method will return the first index it appears in.

	medival_feast = ["ale", "bread", "cheese", "meat", "cheese", "bread", "ale"]
	print(medieval_feast.index("cheese"))

.pop()
The .pop() method removes and returns an item from a list. You would use it instead of del or the remove method to remove an item from a list if you also wanted the removed item to be returned so that you could assign it to a variable,  print it, or use it in some other way.

	cool_music = ["fleetwood mac", "paramore", "pixies"]
	the_best_music = cool_music.pop(0)
	print(cool_music)
	print(the_best_music) # adding an index number will result in that item being returned


Lists vs. Strings

A list and a string both contain an ordered sequence of items. In addition, several things that can be done with strings can also be done with lists. 
Because both of them have index numbers corresponding to what they contain, you can access their contents by index, get slices from them, use the length function to get the number of characters or items that they contain, and you can even iterate through either of them using a for loop or a while loop.

The important distinction between lists and strings is that lists are mutable while strings are immutable. 

For a data type to be mutable means that it can have values changed,  removed, or added. 

	mimi_ex1 = [1, 2, 3]
	mimi_ex1[1] = 5
	print(mimi_ex1) # here we changed the item corresponding to index 1

	mimi_ex2 = "123"
	mimi_ex2[1] = 5
	print(mimi_ex2) # it's not able to change because strings are immutable

Here, you would need to reassign the variable mimi_ex2 to change its value.

Creating new strings from old strings

	str_1 = "No, you can't."
	str_2 = "Yes" + str_1[3:11] + "!"
	print(str_2)


References
You can store numbers and strings to variables through assignments, and you can then assign what those variables have been assigned to new variables.

	ex_1 = 3.14
	ex_2 = "mimi"

	ex_3 = ex_1
	ex+4 = ex_2
	print(ex_3)
	print(ex_4)

You can't do the same thing with lists. When a list is assigned to a variable, instead of the variable actually storing that list like it would a number or string, it stores a reference to that list, which is a value that points to a piece of data such as a list, so not the list itself.


Copy module and deepcopy()

The deepcopy function will allow you to create a copy of a list with its own reference when you need it instead of just a reference to the same list.

	import copy

	ex_1 = [1, 2, 3]
	ex_2 = copy.deepcopy(ex_1) # now the variable ex_2 has been assigned the list 1, 2, 3 but with a whole new reference!

	ex_2[2] = 12
	print(ex_1)
	print(ex_2)

Lists line continuation
Usually python uses four space indents to be able to tell what code belongs to what. However, it is a bit different with lists. Lists can span multiple lines while keeping their items in between brackets.

General line continuation
For things other than lists that you want to span multiple lines, you can use a backlash:

	mimi_math = 2 + \
		    4 + \
		    1
	print(mimi_math)

Introduction to dictionaries
Dictionaries are a data type which can store a collection of values like a list. A dictionary is different from a list in that instead of having to have each of its items be assigned to an index number that is an integer, the items that a dictionary contains are assigned to keys which can be different data types such as floats and strings.

	console = {"nintendo": "switch"} # in this example, the dictionary assigned to the variable console has one key value pair which is made up of the key nintendo and the value switch.
	console = {"nintendo": "switch", "microsoft": "xbox", "sony": "playstation"} # you can have multiple key value pairs in a dictionary

Accessing by key
You can use keys to access values from a dictionary like you would use index numbers to access the items in a list or the characters in a string:

	console = {"nintendo": "switch", "microsoft": "xbox", "sony": "playstation"} 
	print(console["microsoft"])

	val = console["microsoft"] # values from dictionaries can also be assigned to variables
 	print(val)

	print("The " + console["sony"] + " 5 is sony's newest gaming console")

Key values
Keys don't have to be strictly strings, you can use integers, floats, or even boolean values. 

	top_3_desserts = {1: "cheesecake", 2: "petit gateau", 3: "cookies"}
	floats = {1.23: 1000, 3.216318: 10000, 2.7362: 100000}
	mixed = {"string": 1, 10283: 2, 4.839: 3, False: 67}
You can even use different data types in the same dictionary.

Dictionaries are unordered
Lists have to have the exact same items in the exact same order for python to consider them equivalent

	print([2, 4, 6] == [2, 4, 6]) # True
	print([2, 4, 6] == [6, 4, 2]) # False

Two dictionaries being compared need to contain the same key value pairs for them to be considered equal, however, they do not need to be in the same order.

In and not in
You can check whether a key exists by using in or not in operators:

	first = {0: 2.1, 1: 2.2, 2: 2.3}
	print(0 i first)
	print(4 not in first)
	print(5 in first)
	print(1 not in first)


Dictionary methods 1: .keys(), .values(), .items() and .get()

.keys()
This method allows you to get all of the keys from a dictionary. 

	birth_years = {1929: "grandpa", 1936: "grandma", 1969: "dad"}
	print(birth_years.keys()) 

	for key in birth_years.keys(): # you can also use a "for loop" with the .keys() method to iterate through the keys of a dictionary
		print(key)

.values()
This  method allows you to get all of the values from a dictionary.

.items()
Allows you to get the keys and the values of a dictionary at the same time.

	birth_years = {1929: "grandpa", 1936: "grandma", 1969: "dad"}
	print(birth_years.items())

Python returns a list of tuples, each of them containing two items, the first item is a key and the second item and each tuple is a value.

Tuples
A data type which is like a list, except that it's immutable and isn't closed in parentheses instead of square brackets.
If you want to iterate though the tuples returned by items using a for loop, you will have to use two placeholder names separated by a comma and a space.

	birth_years = {1929: "grandpa", 1936: "grandma", 1969: "dad"}
	print(birth_years.items())

	for key, value in birth_years.items():
	print(key, value)

And if you want to print the keys and values on the same lines, you can type a key and value as two items separated by a comma and a space within print.

Using in and not in on values

	birth_years = {1929: "grandpa", 1936: "grandma", 1969: "dad"}
	print("grandma" in birth_years.values()) # True

.get()
Allows you to look for and get a key from a dictionary and return something other than an error message, which stops the program from continuing to run if the key is not found. 

	birth_years = {1929: "grandpa", 1936: "grandma", 1969: "dad"}

	if 1969 in birth_years: 
		print(birth_years[1969])
	else:
		print("1969 is not a key in birth_years.")

print(birth_years.get(1969, "1969 is not a key in  birth_years.")) # we can do a similar thing with just one line, using .get()

Other things you should know about dictionaries
They are immutable data types like lists, which means variables that have been assigned to  dictionaries also hold references to dictionaries, not the dictionary values themselves
What that means in practice is that if you try to make a copy of a dictionary by assigning the dictionary to a new variable, any modifications that you tried to make to the new variable would also affect the original dictionary because they both reference the same dictionary.


If a dictionary gets too long, you can also make it span multiple lines, just make sure that all of the key value pairs are lined up with each other vertically to keep your code  compliant with PEP8 and more readable.

	birth_years = {1929: "grandpa", 
		       1936: "grandma", 
		       1969: "dad", 
		       2000: "me!"}

You can also use the length function to get the length of the dictionary, which is the number of key-value pairs that it contains.

	print(len(birth_years))

Dictionary methods 2: .fromkeys(), .pop(), and .popitem()

.fromkeys()
Returns a dictionary using two values that it was given as arguments. The fist argument is used as keys and the second as a value.

	dic_1 = {}.fromkeys(["name"], "mimi") # when you call .fromkeys() it should be used on a dictionary
	print(dic_1) # given these two arguments .fromkeys() will generate a dictionary with one key value pair

	dic_2 = {}.fromkeys("abc", "mimi") # when using a iterable as the first argument of .fromkeys(), each item in that iterable becomes a key returned, so if we use a string:
	print(dic_2) # then each character in the string will become a key, and each key would be given the second argument as its value

.fromkeys() can take one or two arguments. When you call it, the first argument needs to be an iterable value, such as a string or list. Each item on that iterable value will be used as a key from the dictionary that .fromkeys() will return.
The second argument will be used as a value by the dictionary that .fromkeys() returns. It can be of any data type.

Also, each character or item in an iterable can only be used as a key one time.
You can also give .fromkeys() only one argument

	dic_1 = {}.fromkeys(["name"])
	print(dic_1) # {'name': None}

.pop()
This method does the same thing to lists and dictionaries. It removes an item,  where an "item" in a dictionary is a key value pair.
However, it's a bit different situation for dictionaries since you can't just call .pop() on a dictionary with no argument, and then have it remove the last key value pair. This is because dictionaries are unordered.

	dic_1 = {"author": "J.K. Rowling", "books": "Harry Potter", "volumes": 7}
	dic_1.pop("books")
	print(dic_1)


In addition to removing a key value pair, it also returns the value of the key value pair that has been removed if you assign it to a variable.

	dic_1 = {"author": "J.K. Rowling", "books": "Harry Potter", "volumes": 7}
	reading = dic_1.pop("Volumes")
	print(dic_1)
	print(reading)

.popitem()
Allows you to remove the last key value pair from a dictionary without having to give it an argument.

	dic_1 = {"author": "J.K. Rowling", "books": "Harry Potter", "volumes": 7}
	dic_1.popitem()
	print(dic_1)

Dictionary methods 3: .clear(), .copy(), and .update()

.clear()
This method removes everything from a dictionary that it's called on.

.copy()
Returns us an exact copy of a dictionary that has its own reference, therefore getting around the issue of when a variable is assigned a dictionary, it's actually a reference to a dictionary that its being stored, not an actual dictionary.

	fast_food = {"McDonald's": "Big Mac", 
		     "Burguer King": "Whopper",
		     "Popeyes": "The Sandwich"}
	print(fast_food)
	burguer = fast_food
	burguer["McDonalds"] = "McCheddar"
	print(fast_food)
	print(burguer)

.update()
Allows us to add key value pairs from one dictionary to another or overwrite the values of existing keys in a dictionary with values from another dictionary.

	drinks = {"soda": "Sprite"}
	fast_food.update(drinks)
	print(fast_food)

If the dictionary being added to has a key that is also in the dictionary being used as an argument for update, then the value from the dictionary being used as an argument will overwrite the value from the dictionary being modified.

	fast_food = {"McDonald's": "Big Mac", 
		     "Burguer King": "Whopper",
		     "Popeyes": "The Sandwich"}
	drinks = {"soda": "Sprite"}
	fast_food.update(drinks)
	fast_food["soda": "Coca Cola"]
	print(fast_food)

	fast_food.update(drinks)
	print(fast_food)

Dictionary methods 4:
.setdefault()
Useful for when you go through a dictionary and look for keys only to find that certain keys that you are looking for don't exist.
It allows you to give values to keys if they are not found in a dictionary.

	computers = {"Google": "Chromebook", "Apple": "MacBook", "Microsoft": "Surface Pro"}
	if "Lenovo" not in computers:
		computers["Lenovo"] = "Thinkpad"
	print(computers)

	# now in a more compact way, with .setdefault()
	computers.setdefault("Lenovo", "Thinkpad") # if the key is not found in the dictionary, it will be added and given that value
	print(computers)

Also, if you were to call .setdefault() on a  key that already exists in a dictionary, then that key's existing value will not be overwritten.

.dict()
The dictionary function gives you an alternative way to create a dictionary in Python.

	mimi_dictionary = dict() # if you call this function with no arguments, then it just gives you an empty dictionary
	print(mimi_dictionary)

	babi_dictionary = dict(key="value", a=1, b=2.34, c=True) # if you want to give a dictionary created using the dict() function key-value pairs
	print(babi_dictionary) # the keys created will appear as strings in the output, so when you create keys using dict()
	# they must be made up of letters, underscores, and numbers

The first character of a key cannot be a number when that key is being created by dict().


Introduction to tuples
Tuples are a data type made up of a collection of items. Similar to lists, they have a few key differences.

The first is that they are enclosed in parentheses instead of square brackets.

	tuple_1 = ("a", "b", "c")
	tuple_2 = (1.27, False, [1, 2, 3])
	tuple_3 = (2, 2, 3, 3, 4)

The other way to create a dictionary is by using the tuple() function. This function returns the tuple and takes one argument that must be of an iterable data type. That argument must be a list or string.

	tuple_4 = tuple([2.34, 34.45, 10])
	tuple_5 = tuple("abcdefg")

You can also access values from a tuple by index or slice like you can with lists or strings.
When a tuple is sliced, the resulting slice is also a tuple.

Immutability of tuples
Unlike lists and dictionaries tuples are an immutable data type. 

Why use tuples?
Tuples are useful for when you want to have a collection of data that you know you will not change later on in the program. 

Another reason to use tuples over lists or another mutable data type is that they take up less space in memory, less bytes.


The final instance where you would want to use a tuple over another data type is as a key in a dictionary. You can't use a list for this purpose without getting an error message.

	occupations = {("Angus", "Young"): "musician", ("Narendra", "Modi"): "prime minister", ("Richard", "Branson"): "entrepeneur", ("Quentin", "Tarantino"): "filmmaker"}
	print(occupations)

	for item in occupations.item():
		print(item)

Tuple looping

	major_cities = ("Tokyo", "London", "New York", "Shanghai", "Sydney", "Paris")
	for city in major_cities:
		print(city) 

	# to iterate through the tuple using a while loop, we can start by making a count variable
	# which we will increment to iterate through the index numbers of the tuple
	count = 0
	while count <len(major_cities):
		print(major_cities[count])
		count += 1

Another way to use a while loop is to iterate through a tuple backwards, starting from its last index number.

	backwards = len(major_cities) - 1
	while backwards >= 0
		print(major_cities[backwards])
		backwards -= 1

Tuple slicing with step

	tuple_1 = (1, 2, 3, 4, 5, 6)
	print(tuple_1[::3]) # stride lenght of 3
	print(tuple_1[1::2]) # evens only
	print(tuple_1[7::-1]) # backwards from 8
	print(tuple_1[8::-2]) # odds only backwards

Tuple methods

Nested tuples

	nested_tuple = (1, 2, 3, (4, 5), (6, 7, 8))
	print(nested_tuple[4])
	print(nested_tuple[5][1])

.count()

	repeat = (1, 2, 2, 2, 3, 3, 1, 3, 3)
	print(repeat.count(1))
	print(repeat.count(2))
	print(repeat.count(3))

.index()

	tuple_1 = (1, 1, 7)
	print(tuple_1.index(7))
	print(tuple_1.index(1))

Introduction to sets
A set is a data type that consists of a collection of items, much like a list.
Sets differ from lists in two important ways
-> They cannot have duplicate values in them
-> The items they contain are unordered, like the key-value pairs of a dictionary

	set_1 = {1, 2, 3} # this way of creating a set, between {} is called "set literal"

	set_2 = set({"a", "b", "c"}) # the other way of creating a set is by using the set function, which takes one set as an argument and returns it
	print(set_1)
	print(set_2)

Duplicate items in a set will be ignored in the output.

Also, the order of the items in the output is different from the editor window because items in a set are unordered.
To create an empty set assign the set function without argument to a variable

You can also pass the set function a call of the range function as an argument. The range will be turned into a set.

	set_4 = set(range(1, 12, 2)) # in the range function, the three arguments are the start, stop and step
	print(set_4)

A set can hold items that are different data types.

Unlike lists, sets cannot have their items accessed from them by index, so if you want to access the elements from a set, you can use a for loop.

	set_5 = {1, 2, 3, 4, 5}

	for number in set_5:
		print(number)

You can also check if an item is in a set by using "in".

Sets are useful in situations where you want to use a collection of items, but you don`t want duplicate items in the collection and you also don't care about the order of the items that make up the collection.

	olympic_cities = ["Athens", "Paris", "London", 
			  "Stockholm", "Berlin", "Berlin", 
			  "Tokyo", "London", "London"] # here we have a list with repeating items
	# by making it a set, the output will only show each item once
	print(set(olympic_cities))
	print(len(olympic_cities)) # and we can then use the list function on the set function to convert the set back to a list
	print(list(set(olympic_cities)))
	print(len(list(set(olympic_cities))))

Set methods

.add()
Takes an item of any data type as its argument and adds that to the set it is called on.

.remove()
Takes one argument of any data type and removes it from the set that it was called on.

.discard()
Does the same as .remove() and also takes one argument, but if it's used in a piece of data that is not on a set, it won't return an error message.

.clear()
Takes no arguments, gets rid of everything in the set.

.copy()
Returns a copy of a set that has its own place in memory.

	fruits = {"apple", "banana", "grape", "mango"}
	copied_fruits = fruits.copy()

.union()
Allows you to combine all of the items from two different sets into a single set.

	set_1 = {1, 2, 3}
	set_2 = {4, 5, 6}
	set_3 = set_1.union(set_2)
	print(set_3)

An alternative to the .union() method is the pipe (|) character.

	set_3 = set_1 | set_2

.intersection()
Allows you to find out what items two sections have in common.

	set_3 = set_1.intersection(set_2)

You can also use the ampersand (&) character.

	set_3 = set_1 & set_2

Subtraction and .difference()
You can subtract one set from another based on the items that they have in common.

	set_3 = set_1 - set_2

And you can use .difference()

	set_3 = set_1.difference(set_2)

Set comprehensions
Slightly more advanced way to create a set.

	# there are three things that make a set comprehension
	# first, it must be between{}
	comp_1 = {even+2 for even in range(2, 11, 2)}

	# second, there is a for loop that goes over an iterable data type like a range or a string

	# third, there is an action that is done to each item that the for loop iterates over, that action could be a math operation or a method call
	print(comp_1)

Set comprehension example with repeats:

	comp_2 = {char.lower() for char in "ALLCAPS"}
	print(comp_2)

Binary search

Iterative method
	def binarySearch(array, x, low, high):

    	# Repeat until the pointers low and high meet each other
    	while low <= high:

        	mid = low + (high - low)//2

        	if array[mid] == x:
            		return mid
        	elif array[mid] < x:
            		low = mid + 1
        	else:
            		high = mid - 1

    		return -1

	array = [3, 4, 5, 6, 7, 8, 9]
	x = 4

	result = binarySearch(array, x, 0, len(array)-1)

	if result != -1:
    		print("Element is present at index " + str(result))
	else:
    		print("Not found")


Recursive method

	def binarySearch(array, x, low, high):

    		if high >= low:

        mid = low + (high - low)//2

        # If found at mid, then return it
        if array[mid] == x:
            return mid
        # Search the left half
        elif array[mid] > x:
            return binarySearch(array, x, low, mid-1)
        # Search the right half
        else:
            return binarySearch(array, x, mid + 1, high)
	else:
		return -1


	array = [3, 4, 5, 6, 7, 8, 9]
	x = 4

	result = binarySearch(array, x, 0, len(array)-1)

	if result != -1:
    		print("Element is present at index " + str(result))
	else:
    		print("Not found")

	



